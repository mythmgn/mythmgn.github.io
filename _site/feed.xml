<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序员的梦呓指南</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 27 Jul 2021 17:26:46 +0800</pubDate>
    <lastBuildDate>Tue, 27 Jul 2021 17:26:46 +0800</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>[知识积累]Python踩坑之旅其二裸用os.sytem的原罪</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#python-踩坑之旅其一杀不死的-shell-子进程&quot; id=&quot;markdown-toc-python-踩坑之旅其一杀不死的-shell-子进程&quot;&gt;Python 踩坑之旅其一杀不死的 Shell 子进程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#踩坑案例&quot; id=&quot;markdown-toc-踩坑案例&quot;&gt;踩坑案例&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#填坑解法&quot; id=&quot;markdown-toc-填坑解法&quot;&gt;填坑解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#坑位分析&quot; id=&quot;markdown-toc-坑位分析&quot;&gt;坑位分析&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#技术关键字&quot; id=&quot;markdown-toc-技术关键字&quot;&gt;技术关键字&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#填坑总结&quot; id=&quot;markdown-toc-填坑总结&quot;&gt;填坑总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#前坑回顾&quot; id=&quot;markdown-toc-前坑回顾&quot;&gt;前坑回顾&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#linux中-子进程拷贝父进程哪些信息&quot; id=&quot;markdown-toc-linux中-子进程拷贝父进程哪些信息&quot;&gt;Linux中, 子进程拷贝父进程哪些信息&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#agent常驻进程选择60000端口的意义&quot; id=&quot;markdown-toc-agent常驻进程选择60000端口的意义&quot;&gt;Agent常驻进程选择&amp;gt;60000端口的意义&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;python-踩坑之旅其一杀不死的-shell-子进程&quot;&gt;Python 踩坑之旅其一杀不死的 Shell 子进程&lt;/h1&gt;

&lt;h2 id=&quot;踩坑案例&quot;&gt;踩坑案例&lt;/h2&gt;

&lt;p&gt;今天的坑不仅包括裸用os.system还包括裸用相关的家族:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;os.popen&lt;/li&gt;
  &lt;li&gt;subprocess家族
    &lt;ul&gt;
      &lt;li&gt;subprocess.call&lt;/li&gt;
      &lt;li&gt;subprocess.Popen&lt;/li&gt;
      &lt;li&gt;subprocess.run&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;commands家族 (py2.6后已不推荐使用， depreciated. Py3删除)
    &lt;ul&gt;
      &lt;li&gt;commands.getstatusoutput&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些坑是新同学非常容易踩，而且 code review 过程中容易漏掉:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[1] 长期运行 Service 中裸用以函数家族&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;裸用以上 shell 执行家族可能出现script 执行 hang 住进而 hang 住逻辑执行线程，长时间积累进而占满所有执行线程而服务宕机情况&lt;/li&gt;
  &lt;li&gt;大内存消耗 service fork 子进程直接执行 script
    &lt;ul&gt;
      &lt;li&gt;如果该 script hang 住&lt;/li&gt;
      &lt;li&gt;并且原进程内存进行频繁修改（或者堆积修改， 虽然有 Copy-On-Write技术），但由于内存巨大，依然有内存风险&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;[2] 自动化测试中裸用以上函数家族而不加以保护&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单个 case 如果执行 script 脚本 hang 住会导致 hang 掉整个case 集&lt;/li&gt;
  &lt;li&gt;不设计 case 超时机制导致case 集合运行时间不可控&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;填坑解法&quot;&gt;填坑解法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;支持超时 kill 策略，禁止任何情况下的 shell 执行裸用家族函数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cup&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;shellexec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShellExec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# timeout=None will block the execution until it finishes
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;shellexec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/bin/ls'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# timeout&amp;gt;=0 will open non-blocking mode
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# The process will be killed if the cmd timeouts
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;shellexec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/bin/ls'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现代码关键:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动新的线程执行， 而不是在 main thread 执行&lt;/li&gt;
  &lt;li&gt;强制超时机制支持， 一旦超时启动 terminate 或者 kill 策略&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现示例可以参考 ShellExec类的run函数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/baidu/CUP/blob/master/cup/shell/oper.py&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;截取部分关键代码如下：&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_pipe_asshell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
          run shell with subprocess.Popen
          &quot;&quot;&quot;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;tempscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NamedTemporaryFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;

              &lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tmpdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tmpprefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tempscript&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w+b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fhandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;fhandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'cd {0};&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getcwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;fhandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;shexe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'sh'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;cmds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shexe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempscript&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;'cup shell execute {0} with script {1}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;cmds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_signal_handle&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;'stdout'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;'stderr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;'returncode'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cmdthd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pipe_asshell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cmdthd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cmdthd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmdthd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isAlive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;str_warn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;'Shell &quot;%s&quot;execution timout:%d. Killed it'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;warnings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str_warn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;RuntimeWarning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGKILL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'returncode'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'stderr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_warn&lt;/span&gt;
          &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;terminate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'returncode'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; \
              &lt;span class=&quot;s&quot;&gt;'self._subpro_data should be a tuple'&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'stdout'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'stderr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;内存消耗型服务/进程， 长期运行服务进程避免fork 进程执行 shell 命令&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;分离相应的脚本执行单元到其他附属服务&lt;/li&gt;
  &lt;li&gt;若不分离，让该长期运行进程保持低内存消耗设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;坑位分析&quot;&gt;坑位分析&lt;/h2&gt;

&lt;p&gt;建议看下第二章节关于进程和子进程继承类信息，script使用上述家族进行执行时，采用了启动一个子进程的方式&lt;/p&gt;

&lt;h2 id=&quot;技术关键字&quot;&gt;技术关键字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;os.system家族&lt;/li&gt;
  &lt;li&gt;subprocess家族&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;填坑总结&quot;&gt;填坑总结&lt;/h2&gt;

&lt;p&gt;Shell执行是个非常常见的操作，所以很多同学特别是新同学，在使用过程中经常不注意而随意使用。 裸用一时爽，进程死亡火葬场&lt;/p&gt;

&lt;h1 id=&quot;前坑回顾&quot;&gt;前坑回顾&lt;/h1&gt;

&lt;h2 id=&quot;linux中-子进程拷贝父进程哪些信息&quot;&gt;Linux中, 子进程拷贝父进程哪些信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;先说与父进程不同的
    &lt;ul&gt;
      &lt;li&gt;pid, ppid&lt;/li&gt;
      &lt;li&gt;memory locks&lt;/li&gt;
      &lt;li&gt;tms_utime、tms_stime、tms_cutime、tms_ustime&lt;/li&gt;
      &lt;li&gt;pending signals&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/34452654/what-child-does-not-inherit-semaphore-adjustments-from-its-parent-semop2-mea&quot;&gt;semaphore adjustments&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;file lock&lt;/li&gt;
      &lt;li&gt;pending alarms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料来源:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux Programmer’s Manual ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man fork&lt;/code&gt; )
    &lt;ul&gt;
      &lt;li&gt;CentOS release 6.3 (Final)&lt;/li&gt;
      &lt;li&gt;Linux Kernel 2.6.32&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
fork&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;  creates a new process by duplicating the calling process.  The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the follow-
ing points:

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child has its own unique process ID, and this PID does not match the ID of any existing process group &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;setpgid&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child&lt;span class=&quot;s1&quot;&gt;'s parent process ID is the same as the parent'&lt;/span&gt;s process ID.

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit its parent&lt;span class=&quot;s1&quot;&gt;'s memory locks (mlock(2), mlockall(2)).

    *  Process resource utilizations (getrusage(2)) and CPU time counters (times(2)) are reset to zero in the child.

    *  The child'&lt;/span&gt;s &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;of pending signals is initially empty &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;sigpending&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit semaphore adjustments from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;semop&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit record locks from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;fcntl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit timers from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;setitimer&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, alarm&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, timer_create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit outstanding asynchronous I/O operations from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;aio_read&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, aio_write&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;, nor does it inherit any asynchronous I/O contexts from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;seeio_setup&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

       The process attributes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the preceding list are all specified &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;POSIX.1-2001.  The parent and child also differ with respect to the following Linux-specific process attributes:

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The child does not inherit directory change notifications &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dnotify&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; from its parent &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;see the description of F_NOTIFY &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;fcntl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The prctl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; PR_SET_PDEATHSIG setting is reset so that the child does not receive a signal when its parent terminates.

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  Memory mappings that have been marked with the madvise&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; MADV_DONTFORK flag are not inherited across a fork&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  The termination signal of the child is always SIGCHLD &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;see clone&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在说继承、拷贝父进程的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包括
    &lt;ul&gt;
      &lt;li&gt;内部数据空间&lt;/li&gt;
      &lt;li&gt;堆栈&lt;/li&gt;
      &lt;li&gt;用户 ID、组 ID、eid 有效用户 id、有效组 id、用户 id 标志和设置组 id 标志&lt;/li&gt;
      &lt;li&gt;进程组 id&lt;/li&gt;
      &lt;li&gt;会话 id&lt;/li&gt;
      &lt;li&gt;终端&lt;/li&gt;
      &lt;li&gt;当前目录、根目录&lt;/li&gt;
      &lt;li&gt;文件模式屏蔽字&lt;/li&gt;
      &lt;li&gt;信号屏蔽设置&lt;/li&gt;
      &lt;li&gt;打开文件描述符&lt;/li&gt;
      &lt;li&gt;环境&lt;/li&gt;
      &lt;li&gt;共享存储段&lt;/li&gt;
      &lt;li&gt;存储映射&lt;/li&gt;
      &lt;li&gt;资源限制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在父进程创建 (fork) 出一个子进程过程中, 为了加速, 会使用叫做 copy-on-write 的技术. 
	- 这项技术在存储软件领域也经常使用
	- &lt;a href=&quot;https://unix.stackexchange.com/questions/58145/how-does-copy-on-write-in-fork-handle-multiple-fork&quot;&gt;附上一个关于它的讨论，点击查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;agent常驻进程选择60000端口的意义&quot;&gt;Agent常驻进程选择&amp;gt;60000端口的意义&lt;/h2&gt;

&lt;p&gt;在 Linux 系统中， 一般系统会自动替程序选择端口连接到用户指定的目的端口， 而这个端口范围是提前设定好的， 比如作者的 centos：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /proc/sys/net/ipv4/ip_local_port_range
10000   60000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;选择 60000 以上的端口可以避免冲突&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/solohac/p/4154180.html&quot;&gt;附上一篇讨论该ip_local_port_range的文章，欢迎查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 10 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/Python-%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85%E5%85%B6%E4%BA%8C%E8%A3%B8%E7%94%A8%E7%B1%BBos.system%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%BD%AA/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/Python-%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85%E5%85%B6%E4%BA%8C%E8%A3%B8%E7%94%A8%E7%B1%BBos.system%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%BD%AA/</guid>
        
        <category>Python踩坑之旅,知识积累</category>
        
        
        <category>知识积累</category>
        
      </item>
    
      <item>
        <title>[知识积累]Python踩坑之旅其一杀不死的Shell子进程</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#11-踩坑案例&quot; id=&quot;markdown-toc-11-踩坑案例&quot;&gt;1.1 踩坑案例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#12-填坑解法&quot; id=&quot;markdown-toc-12-填坑解法&quot;&gt;1.2 填坑解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#13-坑位分析&quot; id=&quot;markdown-toc-13-坑位分析&quot;&gt;1.3 坑位分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#14-坑后扩展&quot; id=&quot;markdown-toc-14-坑后扩展&quot;&gt;1.4 坑后扩展&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#141-扩展知识&quot; id=&quot;markdown-toc-141-扩展知识&quot;&gt;1.4.1 扩展知识&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#141-技术关键字&quot; id=&quot;markdown-toc-141-技术关键字&quot;&gt;1.4.1 技术关键字&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#15-填坑总结&quot; id=&quot;markdown-toc-15-填坑总结&quot;&gt;1.5 填坑总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-踩坑案例&quot;&gt;1.1 踩坑案例&lt;/h2&gt;

&lt;p&gt;踩坑的程序是个常驻的Agent类管理进程, 包括但不限于如下类型的任务在执行:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a. 多线程的网络通信包处理
	- 和控制Master节点交互
	- 有固定Listen端口
b. 定期作业任务, 通过subprocess.Pipe执行shell命令
c. etc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;发现坑的过程很有意思:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a.重启Agent发现Port被占用了&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;=&amp;gt; 立刻&lt;strong&gt;想到可能进程没被杀死, 是不是停止脚本出问题&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;=&amp;gt; 排除发现不是, Agent进程确实死亡了&lt;/li&gt;
      &lt;li&gt;=&amp;gt; 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netstat -tanop|grep port_number&lt;/code&gt; 发现端口确实有人占用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;=&amp;gt; 调试环境, &lt;strong&gt;直接杀掉占用进程了之, 错失首次发现问题的机会&lt;/strong&gt;
&lt;strong&gt;b.问题&lt;/strong&gt;在一段时间后&lt;strong&gt;重现&lt;/strong&gt;， 重启后Port还是被占用&lt;/li&gt;
  &lt;li&gt;定位问题出现在一个叫做xxxxxx.sh的脚本, 该脚本占用了Agent使用的端口
    &lt;ul&gt;
      &lt;li&gt;=&amp;gt; 奇了怪了, 一个xxx.sh脚本使用这个奇葩Port干啥(大于60000的Port, 有兴趣的砖友可以想下为什么Agent默认使用6W+的端口)&lt;/li&gt;
      &lt;li&gt;=&amp;gt; review&lt;strong&gt;该脚本并没有进行端口监听的代码&lt;/strong&gt;
一拍脑袋, &lt;strong&gt;c.进程共享了父进程资源&lt;/strong&gt;了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;=&amp;gt; 溯源该脚本,发现确实是Agent启动的任务中的脚本之一&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 问题基本定位, 该脚本属于Agent调用的脚本&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 该Agent继承了Agent原来的资源FD, 也就是这个port&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 虽然该脚本由于超时被动触发了terminate机制, 但terminate并没有干掉这个子进程&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 该脚本进程的父进程(ppid) 被重置为了1
&lt;strong&gt;d.问题&lt;/strong&gt;&lt;strong&gt;出在脚本进程超时kill逻辑&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12-填坑解法&quot;&gt;1.2 填坑解法&lt;/h2&gt;

&lt;p&gt;通过代码review, 找到shell具体执行的库代码如下:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_signal_handle&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 重点是shell=True !
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;把上述代码改为:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_subpro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_signal_handle&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 重点是去掉了shell=True
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-坑位分析&quot;&gt;1.3 坑位分析&lt;/h2&gt;

&lt;p&gt;Agent会在一个新创建的threading线程中执行这段代码, 如果线程执行时间超时(xx seconds), 会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self._subpro.terminate()&lt;/code&gt;终止该脚本.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启用新线程执行该脚本&lt;/li&gt;
  &lt;li&gt;如果出现问题,执行超时防止hang住其他任务执行调用terminate杀死进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;深层问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python 2.7.x中subprocess.Pipe 如果shell=True, 会默认把相关的pid设置为shell(sh/bash/etc)本身(执行命令的shell父进程), 并非执行cmd任务的那个进程&lt;/li&gt;
  &lt;li&gt;子进程由于会复制父进程的opened FD表, 导致即使被杀死, 依然保留了拥有这个Listened Port FD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样虽然杀死了shell进程(未必死亡, 可能进入defunct状态), 但实际的执行进程确活着. 于是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1.1&lt;/code&gt;中的坑就被结实的踩上了.&lt;/p&gt;

&lt;h2 id=&quot;14-坑后扩展&quot;&gt;1.4 坑后扩展&lt;/h2&gt;

&lt;h3 id=&quot;141-扩展知识&quot;&gt;1.4.1 扩展知识&lt;/h3&gt;

&lt;p&gt;本节扩展知识包括二个部分:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux系统中, 子进程一般会继承父进程的哪些信息&lt;/li&gt;
  &lt;li&gt;Agent这种常驻进程选择&amp;gt;60000端口的意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展知识留到下篇末尾讲述, 感兴趣的可以自行搜索&lt;/p&gt;

&lt;h3 id=&quot;141-技术关键字&quot;&gt;1.4.1 技术关键字&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Linux系统进程&lt;/li&gt;
  &lt;li&gt;Linux随机端口选择&lt;/li&gt;
  &lt;li&gt;程序多线程执行&lt;/li&gt;
  &lt;li&gt;Shell执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;15-填坑总结&quot;&gt;1.5 填坑总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;子进程会继承父进程的资源信息&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果只kill某进程的父进程, 集成了父进程资源的子进程会继续占用父进程的资源不释放, 包括但不限于&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;listened port&lt;/li&gt;
      &lt;li&gt;opened fd&lt;/li&gt;
      &lt;li&gt;etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Python Popen使用上, shell的bool状态决定了进程kill的逻辑, 需要根据场景选择使用方式&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/Python%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85%E4%B9%8B1%E6%9D%80%E4%B8%8D%E6%AD%BB%E7%9A%84shell%E5%AD%90%E8%BF%9B%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/Python%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85%E4%B9%8B1%E6%9D%80%E4%B8%8D%E6%AD%BB%E7%9A%84shell%E5%AD%90%E8%BF%9B%E7%A8%8B/</guid>
        
        <category>Python踩坑之旅,知识积累</category>
        
        
        <category>知识积累</category>
        
      </item>
    
      <item>
        <title>[软件测试] 可测性分析和实践</title>
        <description>&lt;p&gt;软件测试中可测性一般是指对系统的可控性、可观测性进行的评估，借以反映系统设计、实现对测试的友好程度和相应的测试成本。可测性在测试阶段会对系统的测试成本及关联产品代码的Patch次数产生重大影响。如何提高可测性成为软件生命周期特别是前期（设计阶段、coding阶段）重要的一环。 本文带领大家探索在实际项目中可测性相关的实战经验和对应的改进措施。&lt;/p&gt;
&lt;h2&gt;1 提高可测性的切入点&lt;/h2&gt;
&lt;p&gt;可测性的评估和改进最早开始于两个阶段：&lt;/p&gt;
&lt;p&gt;a. 新项目的设计阶段；&lt;/p&gt;
&lt;p&gt;b. 已有项目新功能、新策略的提测阶段。&lt;/p&gt;
&lt;p&gt;这些是提高团队设计的系统可测性和维持系统的设计高可测性的关键时间点。测试人员会利用各种场合、机会强化开发人员对于可测性的重视：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可测性的重要性每次设计讨论会， 测试负责人必提醒大家在设计时注意可测性。否则设计出来的功能很可能需要进行重构。&lt;/li&gt;
&lt;li&gt;可控性
&lt;div id=&quot;lowerFullwidthVCR&quot;&gt;&lt;/div&gt;
&lt;p&gt;每次晨会中的讨论环节， 测试负责人会提醒模块设计人员，设计的功能需要必要的外部控制、执行动作支持，否则QA无法精确控制过程及缩短测试耗时。&lt;/li&gt;
&lt;li&gt;可观测性每个功能进行测试设计阶段，提前和开发人员沟通必要的功能，观察结果集合可以系统外部获得，错误结果可以被暴露而不是由内部逻辑完全消化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那可控性和可观测性又指哪些方面呢？ 如何向开发人员合理的解释可测性？&lt;/p&gt;
&lt;h3&gt;1.1 可控性&lt;/h3&gt;
&lt;p&gt;可控性指系统的状态可受外部控制改变，而不是由内部模块自发的完成。&lt;/p&gt;
&lt;p&gt;举个常见的例子：&lt;/p&gt;
&lt;p&gt;A. 当某文件存在的时候，该模块自动退出；&lt;/p&gt;
&lt;p&gt;B. 当某pid.lock文件存在时，该模块不能启动，即使启动也退出。&lt;/p&gt;
&lt;p&gt;上面的状态改变都是由一个外部的文件控制，拥有可控性。&lt;/p&gt;
&lt;p&gt;说到这里，问题来了，拥有可控性就万事大吉了吗？ 请大家思考，你在实际项目过程中遇到过哪些有可控性但可控性较差的情况？&lt;/p&gt;
&lt;h3&gt;1.2 可观测性&lt;/h3&gt;
&lt;p&gt;可观测性指系统内的重要状态、信息可通过一定手段由外部获得。可观测性不仅能观测系统的输出是否符合设计要求，还影响该系统是否可控。系统的必要状态信息在系统测试控制阶段起决定作用。没有准确的状态信息，测试人员无法判断是否要进行下一步的控制变更。无法控制状态变更，可控性又从何谈起？&lt;/p&gt;
&lt;p&gt;口说无凭，我们来看几个作者实际项目中遇到的真实案例。&lt;/p&gt;
&lt;h2&gt;2 实战分析&lt;/h2&gt;
&lt;h3&gt;[1] 垃圾回收GC&lt;/h3&gt;
&lt;p&gt;垃圾回收GC模块是常见的系统内模块，相信很多测试人员遇到过下面场景或者类似场景：&lt;/p&gt;
&lt;p&gt;开发人员终于在大吼一声后宣布垃圾回收模块完成，她的描述如下：&lt;/p&gt;
&lt;p&gt;1) 该模块定时自动触发。触发条件是每天晚上1点。&lt;/p&gt;
&lt;p&gt;2) 该模块触发后每秒的处理量是N/s。是根据线上情况得到的经验值，硬编码到代码中。&lt;/p&gt;
&lt;p&gt;然后，就没有然后了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.infoq.com/articles/testability-analysis-and-practice/zh/resources/1107040.jpg&quot; width=&quot;200&quot; /&gt;&lt;/p&gt;
&lt;p&gt;测试人员一阵迷茫，这就是全部的询问换来的基本上是&amp;ldquo;它都是全自动的了，你还想要什么的&amp;rdquo;表情。&lt;/p&gt;
&lt;p&gt;因此这个新功能完成后的二次返工是必然的了。&lt;/p&gt;
&lt;p&gt;首先，该模块的可控性太差。测试环境不可以等待每天晚上1点这个时刻，必须有外部能影响这个&amp;rdquo;全自动&amp;ldquo;的手段提供。否则全量的系统测试用例回归会被限定在固定测试时间点且无法调整和更改。&lt;/p&gt;
&lt;p&gt;其次，该模块的每秒处理量必须能更改到符合测试环境。测试环境基本上都是真实环境的放缩，特别是分布式系统等大规模应用。测试环境机器无论是数量还是类型都远低于实际环境。这种条件下，参数的定量调整是必须要完成的辅助支持。&lt;/p&gt;
&lt;p&gt;再次，没有必要的描述如何判断哪些文件/数据被GC掉了。无法观测到执行结果集带来的后果是无法精确的预期测试结果。&lt;/p&gt;
&lt;p&gt;而相应的改进措施就是解决上面提到的问题。&lt;/p&gt;
&lt;h3&gt;[2] 系统内部状态信息&lt;/h3&gt;
&lt;p&gt;为了保证存储的数据高可用，分布式系统会采取多机存储副本方法。即一个数据被N（&gt;=2）个机器以一定的算法存储相同的数据副本。这个时候经常会遇到的问题：&lt;/p&gt;
&lt;p&gt;a) 机器间的数据由于数据复制顺序的不同，会有数据差异。a、b、c三台机器，a、b机器可能已完成一次数据的更新到最新数据版本data1，c还处于老版本data0.&lt;/p&gt;
&lt;p&gt;b) 由于版本差异，内部必须维护副本revision的版本号以进行数据同步和异常处理。&lt;/p&gt;
&lt;p&gt;这种情况， 好的设计原则上要保证多机副本的必要状态信息被外部获取。&lt;/p&gt;
&lt;p&gt;A. 数据的副本分布信息、副本的revision版本号等需要提供接口获得&lt;/p&gt;
&lt;p&gt;B.由于机器宕机造成的副本分布变化要能够及时反映和更新。（比如带一定间隔周期的更新）&lt;/p&gt;
&lt;p&gt;只有在这种必要信息被获取的情况下，测试人员才能更好的掌握系统状态并根据系统状态进行清晰的测试结果预期。&lt;/p&gt;
&lt;h3&gt;[3] 参数的热设定&lt;/h3&gt;
&lt;p&gt;参数的热设定是经常碰到的问题。一个系统越复杂、可定制，它可设定的参数就越多。一个好的设计应该能热设定其中的参数，然后执行重新加载动作。&lt;/p&gt;
&lt;p&gt;举个实际的例子， 下面的配置文件是一个系统的存储节点配置文件截图。该截图仅展示了大约1/5的配置参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.infoq.com/articles/testability-analysis-and-practice/zh/resources/1107041.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;a. 如果参数不可重新热加载，那么测试用例执行过程中都必须进行进程的重启。&lt;/p&gt;
&lt;p&gt;进程的重启势必造成单个测试用例的时间拉长，复杂系统成百+的测试用例会造成总体测试时间的拉长。每个多消耗1-2分钟，整体就是小时级别的时间消耗。这对Slow build或完整性测试集执行来说是个灾难。可测性也比较差。&lt;/p&gt;
&lt;p&gt;b. 参数不可热加载会在系统运维期间失去热调整参数的机会，可能导致系统的间断性停服务。这对基础服务来说是个噩梦，上层依赖于基础服务的应用可能成百上千，停服的代价过于大。一些gdb强行attach进程进行等修改变量的临时方法由于进程状态的不确定性因素会带来不小的风险。作者负责的项目曾出现gdb热修改带来集群主控节点宕机停集群的惨痛经历。&lt;/p&gt;
&lt;p&gt;参数的热设定和加载虽然增加了一定的逻辑复杂度，但对比带来的收益是值得付出并实践的。&lt;/p&gt;
&lt;h3&gt;[4] 系统使用信息统计&lt;/h3&gt;
&lt;p&gt;系统使用信息的统计在如下方面特别重要:&lt;/p&gt;
&lt;p&gt;1) 产品线运营数据，为产品运营、后续产品改进等环节提供一手资料&lt;/p&gt;
&lt;p&gt;2) 运用系统、集群状态信息监控以解决运维过程中发生的问题&lt;/p&gt;
&lt;p&gt;3) 利用系统状态信息进行内部运行状态判定，以测试是否达预期&lt;/p&gt;
&lt;p&gt;1和2虽然不直接涉及可测性，但测试人员在系统设计阶段需要进行这方面的考虑以防止系统开发后期进行的功能性重构带来测试整体架构重构。系统接近尾声进行的功能性重构对测试人员来说是个非常头疼的问题。测试用例依赖的统计信息等接口可能被大量使用，这类的更改带来不小的用例调整、更正工作。&lt;/p&gt;
&lt;p&gt;测试人员在信息统计的设计阶段需要了解系统在现有的设计基础上可能衍生的二期、三期甚至更后期的功能，以提前影响当前的功能设计，提高数据、接口、操作方面的可扩展性。为以后可能产生的新功能打好可测性基础。少埋坑、多考虑场景适应性。&lt;/p&gt;
&lt;p&gt;上面的场景是作者在实际测试项目中经常遇到的，因此抽取出来做个示例。实际的项目测试遇到的场景远比这些复杂、多样且不可预知。这个时候需要大家多思考场景，多根据已有的经验进行防御性准备。&lt;/p&gt;
&lt;p&gt;那有没有通用的提供可测性的方法呢？&lt;/p&gt;
&lt;h2&gt;3 提高可测性的通用方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;摒弃原有的开发人员只进行单纯的代码单元测试的观念，让开发人员也进行系统级测试。作者在实践过程中最推崇的方法就是此条。具体地说，开发人员进行的是系统级测试，禁止刷行覆盖率型的单纯函数覆盖UT。由系统级接口或者功能来驱动整个测试过程。无法直接进行驱动的测试行为需要撰写模拟器或者模拟模块进行。这样开发人员会切身的感受到可控性和可观测性的重要性。进而推动系统在这两个方面的实现更易用和便于测试。由此而来的良性循环能让系统整体可测性始终处于较好水平。&lt;/li&gt;
&lt;li&gt;测试人员深度了解被测系统，能够在可测性出现问题的时候及时指出问题所在。只有深度了解被测系统，详细分析系统实现逻辑和代码，做到可黑盒、可白盒测试的程度，才能提前预测可测性薄弱环节，提前预防这样的事情发生。在可测性出现问题时，及时介入和提出建设性意见。在需要进行测试代码植入以方便测试流畅进行等方面亲自动手，协助开发人员解决问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可测性问题可能出现在系统的各个方面，但只要在系统生命周期的各个环节严格要求并辅以正确的方法，可测性问题就不会成为软件测试中不可攻破的难关。各位朋友，你遇到过哪样的可测性难题呢？如果让你从设计阶段就贯彻好的可测性要求并在整个流程中严格遵守，能否解决你的难题呢？&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E6%B5%8B%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E6%B5%8B%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%9E%E8%B7%B5/</guid>
        
        <category>测试,test,</category>
        
        <category>软件测试</category>
        
        
        <category>测试技术</category>
        
      </item>
    
      <item>
        <title>[技术思考]分布式存储系统的雪崩效应</title>
        <description>&lt;h2&gt;一 分布式存储系统背景&lt;/h2&gt;
&lt;p&gt;副本是分布式存储系统中的常见概念：将一定大小的数据按照一定的冗余策略存储，以保障系统在局部故障情况下的可用性。&lt;/p&gt;
&lt;p&gt;副本间的冗余复制方式有多种，比较常用有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pipeline：像个管道，a-&gt;b-&gt;c，通过管道的方式进行数据的复制。该方式吞吐较高，但有慢节点问题，某一节点出现拥塞，整个过程都会受影响&lt;/li&gt;
&lt;li&gt;分发：client -&gt; a&amp;nbsp; client -&gt;b client -&gt;c。系统整体吞吐较低，但无慢节点问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于冗余副本数目，本文选择常见的三副本方案。&lt;/p&gt;
&lt;p&gt;分布式存储系统一般拥有自动恢复副本的功能，在局部存储节点出错时，其他节点（数据副本的主控节点或者client节点，依副本复制协议而定）自动发起副本修复，将该宕机存储节点上的数据副本恢复到其他健康节点上。在少量宕机情况下，集群的副本自动修复策略会正常运行。但依照大规模存储服务运维经验，月百分之X的磁盘故障率和月千分之X的交换机故障率有很大的可能性导致一年当中出现几次机器数目较多的宕机。另外，批量升级过程中若出现了升级bug，集群按照宕机处理需要进行副本修复，导致原本正常时间内可以完成的升级时间延长，也容易出现数目较多的宕机事件。&lt;/p&gt;
&lt;h2&gt;二 雪崩效应的产生&lt;/h2&gt;
&lt;p&gt;在一段时间内数目较多的宕机事件有较大可能性诱发系统的大规模副本补全策略。目前的分布式存储系统的两个特点导致这个大规模副本补全策略容易让系统产生雪崩效应：&lt;/p&gt;
&lt;p&gt;a. 集群整体的free空间较小：通常整体&lt;=30%, 局部机器小于&lt;=20% 甚至10%&lt;/p&gt;
&lt;div id=&quot;lowerFullwidthVCR&quot;&gt;&lt;/div&gt;
&lt;p&gt;b. 应用混布：不同的应用部署在同一台物理/虚拟机器上以最大化利用硬件资源&lt;/p&gt;
&lt;p&gt;今年火起来的各种网盘、云盘类服务就是a的典型情况。在各大公司拼个人存储容量到1T的背后，其实也在拼运营成本、运维成本。现有的云存储大多只增不减、或者根据数据冷热程度做数据分级（类似Facebook的数据分级项目）。云存储总量大，但增量相对小，为了减少存储资源和带宽资源浪费，新创建的文件若原有的存储数据中已有相同的md5或者sha1签名则当做已有文件做内部链接，不再进行新文件的创建。但即使这样，整体的数据量还是很大。&lt;/p&gt;
&lt;p&gt;目前云存储相关业务未有明显的收入来源，每年却有数万每台的服务器成本，为运营成本的考虑，后端分布式存储系统的空闲率很低。而瞬间的批量宕机会带来大量的副本修复，大量的副本修复很有可能继而打满原本就接近存储quota的其他存活机器，继而让该机器处于宕机或者只读状态。如此继续，整个集群可能雪崩，系统残废。&lt;/p&gt;
&lt;h2&gt;三 预防雪崩&lt;/h2&gt;
&lt;p&gt;本节主要讨论如何在系统内部的逻辑处理上防止系统整体雪崩的发生。预防的重要性大于事故之后的处理，预测集群状态、提前进行优化也成为预防雪崩的一个方向。&lt;/p&gt;
&lt;p&gt;下面选取曾经发生过的几个实际场景与大家分享。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;1.&amp;nbsp;&lt;/b&gt;&lt;b&gt;跨机架副本选择算法和机器资源、用户逻辑隔离&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;OLE_LINK2&quot;&gt;&lt;/a&gt;&lt;b&gt;现场还原：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;某天运维同学发现某集群几十台机器瞬间失联，负责触发修复副本的主控节点开始进行疯狂的副本修复。大量用户开始反馈集群变慢，读写夯住。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;现场应对:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;优先解决&amp;mdash;&amp;mdash;副本修复量过大造成的集群整体受影响。&lt;/p&gt;
&lt;p&gt;a. 处理的工程师当机立断，gdb到进程更改修复副本的条件为副本&lt;2，而非原本的3（replicas_num），让主控节点这个时候仅修复副本数小于2个的文件，即保证未丢失的文件有至少一个冗余副本，防止只有一个副本的数据因可能再次发生的挂机造成文件丢失。&lt;/p&gt;
&lt;p&gt;b. 紧急解决这批机器失联问题，发现是交换机问题，a.b.c.d ip网段的c网段机器批量故障。催促网络组尽快修复。&lt;/p&gt;
&lt;p&gt;c. 副本修复到&gt;=2之后，Gdb更改检测副本不足周期，将几十秒的检测时间推迟到1天。等待网络组解决交换机问题。&lt;/p&gt;
&lt;p&gt;d. 网络恢复，原有的机器重新加入集群。大量2副本文件重新变为3副本，部分3副本全丢失文件找回。&lt;/p&gt;
&lt;p&gt;e. 恢复主控节点到正常参数设置状态，系统开始正常修复。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;改进措施:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;在改进措施前，先分析下这次事件暴露的系统不足：&lt;/p&gt;
&lt;p&gt;1) Master参数不支持热修正，Gdb线上进程风险过大。&lt;/p&gt;
&lt;p&gt;2) 一定数量但局域性的机器故障影响了整体集群（几十台相对一个大集群仍属于局域性故障）。如上所述，月千分之几的故障率总有机会让你的存储系统经历一次交换机故障带来的集群影响。&lt;/p&gt;
&lt;p&gt;案例分析后的改进措施出炉：&lt;/p&gt;
&lt;p&gt;1)&amp;nbsp; Master支持热修正功能排期提前，尽早支持核心参数的热修改。&lt;/p&gt;
&lt;p&gt;热修改在上线后的效果可观，后续规避过数次线上问题。&lt;/p&gt;
&lt;p&gt;2) 在选择数据副本存储宿主机器的pickup算法中加入跨交换机（机架位）策略，强制&amp;mdash;&amp;mdash;或者尽量保证&amp;mdash;&amp;mdash;副本选择时跨机架位。这种算法底下的副本，至少有1个副本与其他两个副本处于不同的交换机下（IP a.b.c.d的c段）。该措施同时作用于新的存储数据副本选择和副本缺失后的副本补全策略，能在副本宿主选择上保证系统不会因为交换机的宕机而出现数据丢失，进而避免一直处于副本补全队列/列表的大量的丢失副本节点加重主控节点负载。&lt;/p&gt;
&lt;p&gt;3) 机器按region划分隔离功能提上日程；用户存储位置按照region进行逻辑划分功能提上日程；Pickup算法加入跨region提上日程。&lt;/p&gt;
&lt;p&gt;a) 机器按照物理位置划分region、用户按照region进行逻辑存储位置划分，能让集群在局部故障的情况下仅影响被逻辑划分进使用这部分机器的用户。&lt;/p&gt;
&lt;p&gt;这样一来，最坏情况无非是这个region不可用，导致拥有这个region读写权限的用户受影响。Pickup算法跨region的设计进一步保证被划分region的用户不会因为一个region不可用而出现数据丢失，因为其他副本存到其他region上了。于是，核心交换机故障导致一个region数百台机器的宕机也不会对集群造成范围过大的影响了。&lt;/p&gt;
&lt;p&gt;b) 增加region可信度概念，将机器的稳定性因素加入到副本冗余算法中。&lt;/p&gt;
&lt;p&gt;当集群规模达到一定量后，会出现机器稳定性不同的问题（一般来说，同一批上线的机器稳定性一致）。通过标记region的稳定性，能强制在选择数据副本的时候将至少一个副本至于稳定副本中，减少全部副本丢失的概率。&lt;/p&gt;
&lt;p&gt;c) Region划分需要综合考虑用户操作响应时间SLA、物理机器稳定情况、地理位置等信息。&lt;/p&gt;
&lt;p&gt;合理的region划分对提升系统稳定性、提升操作相应时间、预防系统崩溃都有益处。精巧的划分规则会带来整体的稳定性提升，但也增加了系统的复杂度。这块如何取舍，留给读者朋友深入思考了。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;2.&amp;nbsp;&lt;/b&gt;&lt;b&gt;让集群流控起来&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;流控方面有个通用且符合分布式存储系统特点的原则：&lt;b&gt;任何操作都不应占用过多的处理时间。&lt;/b&gt;这里的&amp;ldquo;任何操作&amp;rdquo;包含了在系统出现流量激增、局部达到一定数量的机器宕机时进行的操作。只有平滑且成功的处理这些操作，才能保证系统不因为异常而出现整体受影响，甚至雪崩。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;现场还原：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1) 场景1 某天运维同学发现，集群写操作在某段时间大增。通过观察某个存储节点，发现不仅是写、而且是随机写！某些产品线的整体吞吐下降了。&lt;/p&gt;
&lt;p&gt;2) 场景2 某集群存储大户需要进行业务调整，原有的数据做变更，大量数据需要删除。&lt;/p&gt;
&lt;p&gt;运维同学发现，a. 整个集群整体上处于疯狂gc垃圾回收阶段 b. 集群响应速度明显变慢，特别是涉及到meta元信息更新的操作。&lt;/p&gt;
&lt;p&gt;3) 场景3 某天运维同学突然发现集群并发量激增，单一用户xyz进行了大量的并发操作，按照原有的用户调研，该用户不应该拥有如此规模的使用场景。&lt;/p&gt;
&lt;p&gt;此类集群某些操作预期外的激增还有很多，不再累述。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;现场应对:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1) 立刻电联相关用户，了解操作激增原因，不合理的激增需要立刻处理。&lt;/p&gt;
&lt;p&gt;我们发现过如下不合理的激增：&lt;/p&gt;
&lt;p&gt;a. 场景1类：通过Review代码发现，大量的操作进行了随机读写更改。建议用户将随机读写转换为读取后更改+写新文件+删除旧文件，转换随机读写为顺序读写。&lt;/p&gt;
&lt;p&gt;b. 场景3类：某产品线在线上进行了性能测试。运维同学立刻通知该产品线停止了相关操作。所有公有集群再次发通过邮件强调，不可用于性能测试。如有需要，联系相关人员在独占集群进行性能场景测试。&lt;/p&gt;
&lt;p&gt;2) 推动设计和实现集群各个环节的流控机制功能并上线。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;改进措施：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1) 用户操作流控&lt;/p&gt;
&lt;p&gt;a. 对用户操作进行流控限制&lt;/p&gt;
&lt;p&gt;可通过系统内部设计实现，也可通过外部的网络限流等方式实现，对单用户做一定的流控限制，防止单个用户占用过多整个集群的资源。&lt;/p&gt;
&lt;p&gt;b. 存储节点操作流控&lt;/p&gt;
&lt;p&gt;可按照对集群的资源消耗高低分为High &amp;ndash; Medium &amp;ndash; Low三层，每层实现类似于抢token的设计，每层token数目在集群实践后调整为比较适合的值。这样能防止某类操作过多消耗集群负载。若某类操作过多消耗负载，其他操作类的请求有较大delay可能，继而引发timeout后的重试、小范围的崩溃，有一定几率蔓延到整个集群并产生整体崩溃。&lt;/p&gt;
&lt;p&gt;c. 垃圾回收gc单独做流控处理。删除操作在分布式存储系统里面常用设计是：接收到用户删除操作时，标记删除内容的meta信息，直接回返，后续进行策略控制，限流的删除，防止大量的gc操作消耗过多单机存储节点的磁盘处理能力。具体的限流策略和token值设置需要根据集群特点进行实践并得出较优设置。&lt;/p&gt;
&lt;p&gt;2) 流控黑名单&lt;/p&gt;
&lt;p&gt;用户因为对线上做测试类的场景可以通过人为制度约束，但无法避免线上用户bug导致效果等同于线上测试规模的场景。这类的场景一般在短时间内操作数严重超过限流上限。&lt;/p&gt;
&lt;p&gt;对此类场景可进行流控黑名单设置，当某用户短时间内（e.g. 1小时）严重超过设置的上限时，将该用户加入黑名单，暂时阻塞操作。外围的监控会通知运维组同学紧急处理。&lt;/p&gt;
&lt;p&gt;3) 存储节点并发修复、创建副本流控&lt;/p&gt;
&lt;p&gt;大量的数据副本修复操作或者副本创建操作如果不加以速度限制，将占用存储节点的带宽和CPU、内存等资源，影响正常的读写服务，出现大量的延迟。而大量的延迟可能引发重试，加重集群的繁忙程度。&lt;/p&gt;
&lt;p&gt;同一个数据宿主进程需要限制并发副本修复、副本创建的个数，这样对入口带宽的占用不会过大，进程也不会因为过量进行这类操作而增加大量其他操作的延迟时间。这对于采用分发的副本复制协议的系统尤其重要。分发协议一般都有慢节点检查机制，副本流控不会进一步加重系统延迟而增大成为慢节点的可能。如果慢节点可能性增大，新创建的文件可能在创建时就因为慢节点检查机制而缺少副本，这会让集群状况更加恶化。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;3.&amp;nbsp;&lt;/b&gt;&lt;b&gt;提前预测、提前行动&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;1) 预测磁盘故障，容错单磁盘错误。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;场景复现：&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;某厂商的SSD盘某批次存在问题，集群上线运行一段时间后，局部集中出现数量较多的坏盘，但并非所有的盘都损坏。当时并未有单磁盘容错机制，一块磁盘坏掉，整个机器就被置成不可用状态，这样导致拥有这批坏盘的机器都不可用，集群在一段时间内都处于副本修复状态，吞吐受到较大影响。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;改进措施:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;a)&amp;nbsp;&lt;u&gt;对硬盘进行健康性预测，自动迁移大概率即将成为坏盘的数据副本&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;近年来，对磁盘健康状态进行提前预测的技术越来越成熟，技术上已可以预判磁盘健康程度并在磁盘拥有大概率坏掉前，自动迁移数据到其他磁盘，减少磁盘坏掉对系统稳定性的影响。&lt;/p&gt;
&lt;p&gt;b)&amp;nbsp;&lt;u&gt;对单硬盘错误进行容错处理&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;存储节点支持对坏盘的异常处理。单盘挂掉时，自动迁移/修复单盘的原有数据到其他盘，而不是进程整体宕掉，因为一旦整体宕掉，其他盘的数据也会被分布式存储系统当做缺失副本，存储资源紧张的集群经历一次这样的宕机事件会造成长时间的副本修复过程。在现有的分布式存储系统中, 也有类似淘宝TFS那样，每个磁盘启动一个进程进行管理，整机挂载多少个盘就启动多少个进程。&lt;/p&gt;
&lt;p&gt;2) 根据现有存储分布，预测均衡性发展，提前进行负载均衡操作。&lt;/p&gt;
&lt;p&gt;这类的策略设计越来越常见。由于分布式存储集群挂机后的修复策略使得集群某些机器总有几率成为热点机器，我们可以对此类的机器进行热点预测，提前迁移部分数据到相对负载低的机器。&lt;/p&gt;
&lt;p&gt;负载均衡策略和副本选择策略一样，需要取舍复杂度和优化程度问题。复杂的均衡策略带来好的集群负载，但也因此引入高复杂度、高bug率问题。如何取舍，仍旧是个困扰分布式存储系统设计者的难题。&lt;/p&gt;
&lt;h2&gt;四 安全模式&lt;/h2&gt;
&lt;p&gt;安全模式是项目实践过程中产生的防分布式存储系统雪崩大杀器，因此我特别将其单独列为一节介绍&lt;b&gt;。其基本思路是&lt;/b&gt;在一定时间内宕机数目超过预期上限则让集群进入安全模式，按照策略配置、情况严重程度，停止修复副本、停止读写，直到停止一切操作（一般策略）。&lt;/p&gt;
&lt;p&gt;在没有机器region概念的系统中，安全模式可以起到很好的保护作用。我过去参与的一个项目经历的某次大规模宕机，由于没有安全模式，系统进行正常的处理副本修复，生生将原本健康的存储节点也打到残废，进而雪崩，整个集群都陷入疯狂副本修复状态。这种状态之后的集群修复过程会因为已发生的副本修复导致的元信息/实际数据的更改而变的困难重重。 该事件最后结局是数据从冷备数据中恢复了一份，丢失了冷备到故障发生时间的数据。&lt;/p&gt;
&lt;p&gt;当然，安全模式并非完美无缺。&amp;ldquo;一段时间&amp;rdquo;、&amp;ldquo;上限&amp;rdquo;该如何设置、什么时候停副本修复、什么时候停读、什么时候停写、是自己恢复还是人工干预恢复到正常状态、安全模式力度是否要到region级别，这些问题都需要安全模式考虑，而此类的设计一般都和集群设计的目标用户息息相关。举例，如果是低延迟且业务敏感用户，可能会选择小规模故障不能影响读写，而高延迟、高吞吐集群就可以接受停读写。&lt;/p&gt;
&lt;h2&gt;五 思考&lt;/h2&gt;
&lt;p&gt;由于分布式存储系统的复杂性和篇幅所限，本文仅选择有限个典型场景进行了分析和讨论， 真实的分布式存储系统远比这数个案例复杂的多、细节的多。如何平衡集群异常自动化处理和引入的复杂度，如何较好的实现流控和避免影响低延迟用户的响应时间，如何引导集群进行负载均衡和避免因负载均衡带来的过量集群资源开销，这类问题在真实的分布式存储系统设计中层出不穷。如果设计者是你，你会如何取舍呢？&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94/</guid>
        
        <category>分布式系统</category>
        
        <category>雪崩效应</category>
        
        
        <category>技术思考</category>
        
      </item>
    
      <item>
        <title>[知识积累][翻译]软件系统如何打印日志</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1-背景&quot; id=&quot;markdown-toc-1-背景&quot;&gt;1. 背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-方法&quot; id=&quot;markdown-toc-2-方法&quot;&gt;2. 方法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-不要打印无用信息&quot; id=&quot;markdown-toc-21-不要打印无用信息&quot;&gt;2.1 不要打印无用信息&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-不要吝啬打印语句&quot; id=&quot;markdown-toc-22-不要吝啬打印语句&quot;&gt;2.2 不要吝啬打印语句&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#221-适合打印的&quot; id=&quot;markdown-toc-221-适合打印的&quot;&gt;2.2.1 适合打印的&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#222-不适合打印的&quot; id=&quot;markdown-toc-222-不适合打印的&quot;&gt;2.2.2 不适合打印的&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#23-多种打印级别&quot; id=&quot;markdown-toc-23-多种打印级别&quot;&gt;2.3 多种打印级别&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#24-打印测试日志&quot; id=&quot;markdown-toc-24-打印测试日志&quot;&gt;2.4 打印测试日志&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#25-动态日志level&quot; id=&quot;markdown-toc-25-动态日志level&quot;&gt;2.5 动态日志level&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#26-打印性能数据&quot; id=&quot;markdown-toc-26-打印性能数据&quot;&gt;2.6 打印性能数据&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[原文地址]http://googletesting.blogspot.jp/2013/06/optimal-logging.html

目测需要翻墙
作者：Anthony Vallone
翻译: mythmgn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;1-背景&quot;&gt;1. 背景&lt;/h1&gt;
&lt;p&gt;在你的系统故障后，一般需要多久才能找到根本原因？ 5分钟？ 5天？
如果你的回答是[接近五分钟]。可能你的系统有非常棒的Log输出（机制）。
太多时候，这些看起来不是特别重要的处理逻辑如Log输出、Exception处理、测试点等内容都是人们事后才加入的。永远不要低估logging的作用。一个好的日志logging机制可以使调试者需要更少的相关信息来做debug工作。&lt;/p&gt;

&lt;h1 id=&quot;2-方法&quot;&gt;2. 方法&lt;/h1&gt;
&lt;p&gt;以下是数年来对我很有帮助的一些方法：
梳理你那不温不火的日志吧:&lt;/p&gt;

&lt;h2 id=&quot;21-不要打印无用信息&quot;&gt;2.1 不要打印无用信息&lt;/h2&gt;
&lt;p&gt;大量的、（打印速度）能让硬盘着火的打印方式说明你没怎么在日志打印上花精力。如果你大量打印， 需要考虑怎么去减少硬盘存取、维护历史日志文件、将他们归档、并且对它们做查询和信息收集。 更重要的是，事后你会发现这些大量打印的无聊东东会让你很难收集到有价值的信息。信息量太大且无用了。&lt;/p&gt;

&lt;h2 id=&quot;22-不要吝啬打印语句&quot;&gt;2.2 不要吝啬打印语句&lt;/h2&gt;
&lt;p&gt;一般情况下，打印日志是为了找到系统的bug或者复现某个问题、或者对某件事情做确认。
如果你的日志不能帮你找到bug的原因或者不能帮你确认某件事情确实发生了，
你就需要多打印一些，兄弟，不要太吝啬你的硬盘。&lt;/p&gt;

&lt;h3 id=&quot;221-适合打印的&quot;&gt;2.2.1 适合打印的&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[启动阶段] 关键的配置参数&lt;/li&gt;
  &lt;li&gt;[运行阶段] Error级别信息&lt;/li&gt;
  &lt;li&gt;[运行阶段] Warning级别信息&lt;/li&gt;
  &lt;li&gt;[运行阶段] 对持久化的信息做了新增或者改动&lt;/li&gt;
  &lt;li&gt;[运行阶段] 重要的状态变更&lt;/li&gt;
  &lt;li&gt;[逻辑处理] 对系统非常重要的分支被触发, 可能是逻辑上或者某个等待事件方面比较重要的分支.&lt;/li&gt;
  &lt;li&gt;[逻辑处理] 长时间运行的逻辑中周期性处理的部分被触发和完成时&lt;/li&gt;
  &lt;li&gt;[逻辑处理] 在上层函数中做言简意赅的日志打印,反应目前的处理逻辑进行到哪一步了.&lt;/li&gt;
  &lt;li&gt;[资源竞争] 某个可能比较耗时的条件的wait操作将被触发&lt;/li&gt;
  &lt;li&gt;[用户交互] 用户操作&lt;/li&gt;
  &lt;li&gt;[已知风险] 监测到已知风险被触及&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;222-不适合打印的&quot;&gt;2.2.2 不适合打印的&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[内部逻辑] 不要打印函数的入口 = = 除非她十分的重要， 或者在DEBUG level去打印她。&lt;/li&gt;
  &lt;li&gt;[数据记录] 不要打印for while循环内的数据记录 = = 尽量避免打印一个数据比较多的循环内的数据。 可以在上层的大循环中打印。非常重要且数据量小的可以尝试打印。&lt;/li&gt;
  &lt;li&gt;[异常处理] 巨大的信息、或者文件类。 可以用某种方法把她们做归类、聚合，总结性的打印日志&lt;/li&gt;
  &lt;li&gt;[异常处理] 良性、可被正确处理的错误。该类错误可能对日志阅读者产生困惑。可以用DEBUG level的方式打印她。&lt;/li&gt;
  &lt;li&gt;[异常处理] 重复性的错误日志。不要重复的打印相同、相近的日志。 这样打印会很快的充满你的日志、掩盖真正的错误原因。通过打印一条然后标定他的出现次数是个不错的选择。选择有特殊需要和目的的地方进行细致的打印。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;23-多种打印级别&quot;&gt;2.3 多种打印级别&lt;/h2&gt;
&lt;p&gt;不要把所有东西没有区分的打印在同一个层次里面. 最好划分几个层次. 一般的log库都提供数个日志Level.你可以在启动阶段使用其中的几个level. 这能很好的控制日志的详细程度。
经典的几个日志Level有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Debug - 非常详细的打印level、一般只在开发或者调试阶段才会打开这个level.&lt;/li&gt;
  &lt;li&gt;Info - 最受欢迎的level, 一般生产环境都设置成Info Level.&lt;/li&gt;
  &lt;li&gt;Warning - 奇怪或者异常的情况发生时的打印level, 这类日志表明出现了一定问题， 但一般不影响系统的使用。&lt;/li&gt;
  &lt;li&gt;Error - 发生了错误， 但是系统、进程可以恢复。&lt;/li&gt;
  &lt;li&gt;Critical - 发生了重大问题。一般系统、进程等受到影响会死掉、重启或者被关闭。
从实践的经验来看，一般两个日志配置项是需要的。&lt;/li&gt;
  &lt;li&gt;生产环境  - 除了Debug level之外，其他的层次都是需要的。 这种情况下， 一旦发生了错误，一般日志能很好的找到错误原因。&lt;/li&gt;
  &lt;li&gt;开发、调试环境- 在开发新的feature或者模块或者需要复现比较难的生产环境问题时候， 会激活所有的日志level.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-打印测试日志&quot;&gt;2.4 打印测试日志&lt;/h2&gt;

&lt;p&gt;打印日志的质量在生产环境和测试环境是同等重要的。如果在测试环境中，某个测试用例失败了。测试code中打印的日志应该能清晰的反映出这次失败  - – 是用例错误导致的失败、还是被测的程序确实产生了问题。如果反映不出，则这个日志打印规则与生产环境是不统一的，需要调整。&lt;/p&gt;

&lt;p&gt;测试日志应该包含：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;测试执行时的环境信息&lt;/li&gt;
  &lt;li&gt;初始状态&lt;/li&gt;
  &lt;li&gt;程序setup内容&lt;/li&gt;
  &lt;li&gt;测试中的关键步骤的checkpoint点&lt;/li&gt;
  &lt;li&gt;与被测系统的交互&lt;/li&gt;
  &lt;li&gt;测试用例的期望结果 – 若出错，一并打印实际的结果&lt;/li&gt;
  &lt;li&gt;环境清除内容和执行结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;25-动态日志level&quot;&gt;2.5 动态日志level&lt;/h2&gt;

&lt;p&gt;当生产环境发生问题时候，很明显， 大家一般会去聚焦在查找问题、解决问题。&lt;/p&gt;

&lt;p&gt;但与此同时，请应该把log也考虑进来。如果你发现，诶，这次很难发现这个问题的原因，你就赚到了。&lt;/p&gt;

&lt;p&gt;这是一个改善你的日志打印的机会。在fix你的bug或者问题之前，先优化下你的日志，让她下一次在问题发生后能很好、很简单的展示错误发生的原因。&lt;/p&gt;

&lt;p&gt;如果你不能复现这个问题或者这是个不稳定的问题，优化这个log直到当再次发现问题时能很好的帮助debugger追踪到问题。&lt;/p&gt;

&lt;p&gt;在整个开发过程中，用终止进程（abort程序)的方式来改善日志打印方式。当撰写新的代码的时候，应该牢记尽量避免后面来进行人工调试，应该尽量使用log来查找问题。也要常记着思考，这些log能有效的记录现在系统发生了什么？如果不能，说明日志打印不够充分。&lt;/p&gt;

&lt;h2 id=&quot;26-打印性能数据&quot;&gt;2.6 打印性能数据&lt;/h2&gt;
&lt;p&gt;打印性能数据能很好的帮助debug性能相关的问题。举个例子，在一个大型系统中，一般很难发现某个动作、命令timeout的原因，除非你在每一个很重要的时间点上做了日志log追踪和打印。这种日志优化可以通过打印耗时的处理逻辑的入口和出口来实现，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重要的系统调用&lt;/li&gt;
  &lt;li&gt;网络请求处理&lt;/li&gt;
  &lt;li&gt;CPU密集型的处理逻辑&lt;/li&gt;
  &lt;li&gt;已链接的设备、模块的互动操作&lt;/li&gt;
  &lt;li&gt;事务等&lt;/li&gt;
  &lt;li&gt;多进程、多线程执行中记录事务的踪迹&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们应该为可能被多个进程、线程处理的事务创建唯一的标识码。可以在事务的初始阶段创建，并传递给每一个事务的处理逻辑。这个唯一的标识码应该被每个处理逻辑在打印日志的时候包含， 这样在系统并行的处理多个事务的时候可以很方便快捷的找到你需要找的那一个。&lt;/p&gt;

&lt;p&gt;打印日志并监控你的系统模块吧!!!&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/optimal-logging/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/optimal-logging/</guid>
        
        
        <category>知识积累</category>
        
      </item>
    
  </channel>
</rss>
